# -*- coding: utf-8 -*-
"""Heart failure - with ROS+PSO+KNN.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xly38F4frCRmA_cWSsvPhf86qeyxOktr

Hasil akurasi ROS + PSO + KNN = 90%
ROS > PSO > Normalisasi Data > KNN
"""

import pandas as pd
import numpy as np
import pickle
import matplotlib.pyplot as plt
from sklearn.preprocessing import StandardScaler
from sklearn.neighbors import KNeighborsClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score
from sklearn.feature_selection import SelectKBest
from sklearn.feature_selection import chi2

# Membaca dataset
df = pd.read_csv('heart_failure.csv')

# cek missing value
pd.isnull(df).sum()

"""Cek distribusi label"""

# Menghitung distribusi label
label_counts = df['DEATH_EVENT'].value_counts()

print(label_counts)
# Membuat plot histogram atau diagram batang
plt.figure(figsize=(10, 6))
label_counts.plot(kind='bar', color='skyblue')
plt.title('Distribusi Label')
plt.xlabel('Label')
plt.ylabel('Jumlah')
plt.show()

"""Balancing Data menggunakan RandomOverSampler"""

from imblearn.over_sampling import RandomOverSampler

# Memisahkan fitur (X) dan label (y)
X = df.drop('DEATH_EVENT', axis=1)
y = df['DEATH_EVENT']

# Membuat instance dari RandomOverSampler
ros = RandomOverSampler(random_state=42)

# Melakukan oversampling pada dataset
X_resampled, y_resampled = ros.fit_resample(X, y)

resampled_df = pd.DataFrame(X_resampled, columns=X.columns)
resampled_df['DEATH_EVENT'] = y_resampled

# Menampilkan distribusi label setelah oversampling
plt.figure(figsize=(8, 5))
pd.Series(y_resampled).value_counts().plot(kind='bar', color='skyblue')
plt.title('Distribusi Label setelah Oversampling')
plt.xlabel('Label')
plt.ylabel('Jumlah')
plt.show()

# Simpan objek RandomOverSampler ke dalam file pickle
with open('ros_model.pkl', 'wb') as f:
    pickle.dump(ros, f)

# Mendownload file pickle
from google.colab import files
files.download('ros_model.pkl')

# cek data setelah di balancing
resampled_df

"""Install library pyswarms untuk PSO"""

!pip install pyswarms

import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import accuracy_score
import pyswarms as ps

# Pisahkan fitur dan target (informasi cluster tidak digunakan)
X = resampled_df.drop(['DEATH_EVENT'], axis=1)
y = resampled_df['DEATH_EVENT']


# Definisikan fungsi objektif yang akan dioptimalkan
def objective_function(params):
    # Extract K value (must be an integer) and distance metric
    K = int(params[0])
    if K < 1:  # Ensure K is at least 1
        K = 1
    # Buat model KNN dengan parameter K
    model = KNeighborsClassifier(n_neighbors=K)
    model.fit(X_train, y_train)
    y_pred = model.predict(X_test)
    # Hitung akurasi dan ingin memaksimalkan akurasi
    accuracy = accuracy_score(y_test, y_pred)
    # PSO meminimalkan fungsi objektif, jadi kita gunakan -accuracy
    return -accuracy

# Definisikan parameter untuk PSO
options = {'c1': 1.49, 'c2': 1.49, 'w': 0.72, 'k': 30, 'p': 2}

# Definisikan batas pencarian
# Di sini, kita hanya mencari nilai K antara 1 dan 50 (karena hanya mencari satu parameter)
bounds = (np.array([1]), np.array([50]))

# Inisialisasi optimasi swarm
optimizer = ps.single.GlobalBestPSO(n_particles=50, dimensions=1, options=options, bounds=bounds)

# Jalankan optimasi
best_cost, best_pos = optimizer.optimize(objective_function, iters=100)

# Hasil terbaik
best_K = int(best_pos[0])
print(f"Nilai K terbaik: {best_K}")
print(f"Akurasi terbaik: {-best_cost}")

# Membangun model KNN dengan parameter terbaik dan evaluasi pada test set
best_model = KNeighborsClassifier(n_neighbors=best_K)
best_model.fit(X_train, y_train)
y_pred = best_model.predict(X_test)
final_accuracy = accuracy_score(y_test, y_pred)
print(f"Akurasi model dengan K terbaik pada test set: {final_accuracy}")

"""Feature Selection dengan PSO"""

# Pisahkan fitur dan target
X_selected = resampled_df[X.columns[selected_features]] # fitur yang digunakan hanya fitur yang telah diseleksi sebelumnya
y = resampled_df['DEATH_EVENT']

# Split data menjadi train dan test set (80:20)
X_train, X_test, y_train, y_test = train_test_split(X_selected, y, test_size=0.2, random_state=42)
X_train

# Normalisasi fitur
scaler = StandardScaler()
X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)

print(X_train)

# Simpan model ke file pickle
with open('scaler.pkl', 'wb') as f:
    pickle.dump(scaler, f)

# Mendownload file pickle
from google.colab import files
files.download('scaler.pkl')

from sklearn.metrics import confusion_matrix,accuracy_score, classification_report
import time

start = time.time()

# Inisialisasi dan latih model KNN dengan parameter berikut:
knn_classifier = KNeighborsClassifier(
    n_neighbors=24,  # Ganti dengan jumlah tetangga yang diinginkan
    weights='distance',  # Ganti dengan 'uniform' atau 'distance' sesuai kebutuhan
    algorithm='auto',  # Ganti dengan 'ball_tree', 'kd_tree', atau 'brute'
    leaf_size=5,  # Ganti dengan ukuran daun yang diinginkan
    p=2  # Ganti dengan 1 untuk metrik jarak Manhattan atau 2 untuk Euclidean
)

# Latih model pada data training
knn_classifier.fit(X_train, y_train)

# Prediksi pada data test
y_pred = knn_classifier.predict(X_test)

# Hitung confusion matrix
cm = confusion_matrix(y_test, y_pred)

# Hitung akurasi
accuracy = accuracy_score(y_test, y_pred)
print("\nAccuracy:", accuracy)

# Tampilkan confusion matrix
print("Confusion Matrix:")
print(cm)

end = time.time()

waktu = end - start

# Cetak akurasi
print('Waktu ', round(waktu, 4))
print("Akurasi model: {:.2f}%".format(accuracy * 100))

# Tampilkan juga classification report yang menyediakan precision, recall, dan f1-score
print("Classification Report:")
print(classification_report(y_test, y_pred))

# Simpan model ke file pickle
with open('knn_model.pkl', 'wb') as f:
    pickle.dump(knn_classifier, f)

print("Model KNN telah disimpan sebagai 'knn_model.pkl'")

# Mendownload file pickle
from google.colab import files
files.download('knn_model.pkl')

import pandas as pd
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import accuracy_score, confusion_matrix, classification_report
import time

# Inisialisasi nilai n_particles dan k_values
n_particles_values = range(1, 50)
k_values = range(1, 50)

# Simpan hasil akurasi setiap iterasi
results = []

# Latih dan evaluasi model KNN untuk setiap kombinasi n_particles dan k
for n_particles in n_particles_values:
    for k in k_values:
        # Inisialisasi dan latih model KNN dengan parameter tertentu
        knn_classifier = KNeighborsClassifier(
            n_neighbors=24,
            weights='distance',
            algorithm='auto',
            leaf_size=5,
            p=2
        )

        # Latih model pada data training
        knn_classifier.fit(X_train, y_train)

        # Prediksi pada data test
        y_pred = knn_classifier.predict(X_test)

        # Hitung akurasi
        accuracy = accuracy_score(y_test, y_pred)

        # Simpan hasil akurasi
        results.append({
            'n_particles': n_particles,
            'k': k,
            'accuracy': accuracy
        })

# Konversi hasil akurasi ke dalam DataFrame
results_df = pd.DataFrame(results)

# Tampilkan DataFrame
print(results_df)

"""Visualisasi Confusion Matrix"""

import seaborn as sns

# Visualize confusion matrix with seaborn
plt.figure(figsize=(8, 6))
sns.heatmap(cm, annot=True, fmt="d", cmap="Blues", xticklabels=np.unique(y_test), yticklabels=np.unique(y_test))
plt.xlabel('Predicted')
plt.ylabel('True')
plt.title('Confusion Matrix')
plt.show()